# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.9
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""
The smartcard.scard module is a simple wrapper on top of the C language
PCSC SCardXXX API.

The smartcard.scard module is the lower layer of the pyscard
framework that provides a higher level interface.

You should avoid using the smartcard.scard package directly, and use the
pyscard directly because:

 - smartcard.scard being a C wrapper, the code tends to look like C code
   written in python syntax

 - the smartcard package provides higher level abstractions (e.g.
   CardType, CardConnection), and makes programming easier since it is
   totally written in Python

You can still use the smartcard.scard package if you want to write your
own framework, or if you want to perform quick-and-dirty port of C
language programs using SCardXXX calls, or if there are features of
SCardXXX API that you want to use and that are not available in the
pyscard library.

Introduction

The smartcard.scard module is a Python wrapper around PCSC smart card base
services.  On Windows, the wrapper is performed around the smart card base
components winscard library.  On linux and OS X, the wrapper is performed
around the PCSC-lite library.


The smartcard.scard module provides mapping for the following API functions,
depending on the Operating System:

=============================== ======= =======
Function                        Windows  Linux 
                                         OS X  
=============================== ======= =======
GetOpenCardName                                
SCardAddReaderToGroup              Y           
SCardBeginTransaction              Y       Y   
SCardCancel                        Y       Y   
SCardConnect                       Y       Y   
SCardControl                       Y       Y   
SCardDisconnect                    Y       Y   
SCardEndTransaction                Y       Y   
SCardEstablishConteYt              Y       Y   
SCardForgetCardType                Y           
SCardForgetReader                  Y           
SCardForgetReaderGroup             Y           
SCardFreeMemory                                
SCardGetAttrib                     Y       Y   
SCardGetCardTypeProviderName       Y           
SCardGetErrorMessage               Y           
SCardGetProviderId                             
SCardGetStatusChange               Y       Y   
SCardIntroduceCardType             Y           
SCardIntroduceReader               Y           
SCardIntroduceReaderGroup          Y           
SCardIsValidConteYt                Y       Y   
SCardListCards                     Y           
SCardListInterfaces                Y           
SCardListReaderGroups              Y       Y   
SCardListReaders                   Y       Y   
SCardLocateCards                   Y           
SCardReconnect                     Y       Y   
SCardReleaseConteYt                Y       Y   
SCardRemoveReaderFromGroup         Y           
SCardSetAttrib                     Y       Y   
SCardSetCartTypeProviderName                   
SCardStatus                        Y       Y   
SCardTransmit                      Y       Y   
SCardUIDlgSelectCard                           
=============================== ======= =======

Comments, bug reports, improvements welcome.

-------------------------------------------------------------------------------
Copyright 2001-2012 gemalto
@Author: Jean-Daniel Aussel, mailto:jean-daniel.aussel@gemalto.com
@Author: Ludovic Rousseau, mailto:ludovic.rousseau@free.fr

This file is part of pyscard.

pyscard is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or (at
your option) any later version.

pyscard is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with pyscard; if not, write to the Free Software Foundation,
Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA


"""


from sys import version_info
if version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_scard')).lstrip('.')
        return importlib.import_module(mname)
    _scard = swig_import_helper()
    del swig_import_helper
elif version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_scard', [dirname(__file__)])
        except ImportError:
            import _scard
            return _scard
        if fp is not None:
            try:
                _mod = imp.load_module('_scard', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _scard = swig_import_helper()
    del swig_import_helper
else:
    import _scard
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


def SCardAddReaderToGroup(hcontext, readername, groupname):
    """
    SCardAddReaderToGroup( hcontext,  readername,  groupname) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    readername: card reader name
    groupname: card reader group name



    adds a reader to a reader group

    Windows only, not supported by PCSC lite wrapper.

    example:

    from smartcard.scard import *
    ... establish context ...
        newgroup = 'SCard$MyOwnGroup'
        reader = 'SchlumbergerSema Reflex USB v.2 0'
        readeralias = 'SchlumbergerSema Reflex USB v.2 0 alias'
        hresult = SCardIntroduceReader(hcontext, readeralias, reader])
        if hresult != SCARD_S_SUCCESS:
            raise error, 'Unable to introduce reader: ' + SCardGetErrorMessage(hresult)

        hresult = SCardAddReaderToGroup(hcontext, readeralias, newgroup)
        if hresult!=0:
            raise error, 'Unable to add reader to group: ' + SCardGetErrorMessage(hresult)

    ...

    """
    return _scard.SCardAddReaderToGroup(hcontext, readername, groupname)

def SCardForgetCardType(hcontext, cardname):
    """
    SCardForgetCardType( hcontext,  cardname) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    cardname: friendly name of a card



    removes an introduced smart card from the smart card subsystem.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    ... establish context ...
    hresult = SCardForgetCardType(hcontext, 'myCardName')
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to remove card type: ' + SCardGetErrorMessage(hresult)
    ...


    """
    return _scard.SCardForgetCardType(hcontext, cardname)

def SCardForgetReader(hcontext, readername):
    """
    SCardForgetReader( hcontext,  readername) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    readername: card reader name



    Removes a previously introduced smart card reader from the smart
    card subsystem.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    ... establish context ...
    ...
    hresult = SCardForgetReader(hcontext, dummyreader)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to forget readers ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardForgetReader(hcontext, readername)

def SCardForgetReaderGroup(hcontext, groupname):
    """
    SCardForgetReaderGroup( hcontext,  groupname) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    groupname: card reader group name



    Removes a previously introduced smart card reader group from the smart
    card subsystem. Although this function automatically clears all readers
    from the group, it does not affect the existence of the individual readers
    in the database.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    ... establish context ...
    ...
    hresult = SCardForgetReaderGroup(hcontext, newgroup)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Unable to forget reader group: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardForgetReaderGroup(hcontext, groupname)

def SCardGetCardTypeProviderName(hcontext, cardname, dwProviderId):
    """
    SCardGetCardTypeProviderName( hcontext,  cardname,  dwProviderId) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    cardname: friendly name of a card
    dwProviderId: provider type, SCARD_PROVIDER_PRIMARY or SCARD_PROVIDER_CSP



    Returns the name of the module (dynamic link library) containing the
    provider for a given card name and provider type.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    ... establish context ...
    hresult, cards = SCardListCards(hcontext, [], [])
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failure to list cards: ' + SCardGetErrorMessage(hresult)
    for i in cards:
        hresult, providername = SCardGetCardTypeProviderName(hcontext, i, SCARD_PROVIDER_PRIMARY)
        if hresult == SCARD_S_SUCCESS:
             print providername
        hresult, providername = SCardGetCardTypeProviderName(hcontext, i, SCARD_PROVIDER_CSP)
        if hresult == SCARD_S_SUCCESS:
             print providername
    ...

    """
    return _scard.SCardGetCardTypeProviderName(hcontext, cardname, dwProviderId)

def SCardIntroduceCardType(hcontext, cardname, primaryprovider, providerlist, atr, mask):
    """
    SCardIntroduceCardType( hcontext,  cardname, GUID primaryprovider, GUID[] providerlist, byte[] atr, byte[] mask) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    cardname: friendly name of a card
    primaryprovidername: GUID of the smart card primary service provider
    providerlist: list of GUIDs of interfaces supported by smart card
    atr: card ATR
    mask: mask to apply to card ATR



    Introduces a smart card to the smart card subsystem (for the active user)
    by adding it to the smart card database.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    ...
    znewcardName = 'dummy-card'
    znewcardATR = [0x3B, 0x77, 0x94, 0x00, 0x00, 0x82, 0x30, 0x00, 0x13, 0x6C, 0x9F, 0x22]
    znewcardMask = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    znewcardPrimGuid = smartcard.guid.strToGUID('{128F3806-4F70-4ccf-977A-60C390664840}')
    znewcardSecGuid = smartcard.guid.strToGUID('{EB7F69EA-BA20-47d0-8C50-11CFDEB63BBE}')
    ...
    hresult = SCardIntroduceCardType(hcontext, znewcardName,
        znewcardPrimGuid, znewcardPrimGuid + znewcardSecGuid,
        znewcardATR, znewcardMask)

    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to introduce card type: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardIntroduceCardType(hcontext, cardname, primaryprovider, providerlist, atr, mask)

def SCardIntroduceReader(hcontext, readername, devicename):
    """
    SCardIntroduceReader( hcontext,  readername,  devicename) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    readername: card reader name
    devicename: card reader device name



    Introduces a reader to the smart card subsystem.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    ...
    dummyreader = readers[0] + ' dummy'
    hresult = SCardIntroduceReader(hcontext, dummyreader, readers[0])
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Unable to introduce reader: ' + dummyreader + ' : ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardIntroduceReader(hcontext, readername, devicename)

def SCardIntroduceReaderGroup(hcontext, groupname):
    """
    SCardIntroduceReaderGroup( hcontext,  groupname) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    groupname: card reader group name



    Introduces a reader group to the smart card subsystem. However, the
    reader group is not created until the group is specified when adding
    a reader to the smart card database.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult = SCardIntroduceReaderGroup(hcontext, 'SCard$MyOwnGroup')
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Unable to introduce reader group: ' + SCardGetErrorMessage(hresult)
    hresult = SCardAddReaderToGroup(hcontext, 'SchlumbergerSema Reflex USB v.2 0', 'SCard$MyOwnGroup')
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Unable to add reader to group: ' + SCardGetErrorMessage(hresult)

    """
    return _scard.SCardIntroduceReaderGroup(hcontext, groupname)

def SCardListInterfaces(hcontext, cardname):
    """
    SCardListInterfaces( hcontext,  cardname) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    cardname: friendly name of a card



    Provides a list of interfaces supplied by a given card.  The caller
    supplies the name of a smart card previously introduced to the subsystem,
    and receives the list of interfaces supported by the card

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, interfaces = SCardListInterfaces(hcontext, 'Schlumberger Cryptoflex 8k v2')
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to list interfaces: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardListInterfaces(hcontext, cardname)

def SCardListCards(hcontext, atr, providerlist):
    """
    SCardListCards( hcontext, byte[] atr, GUID[] providerlist) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    atr: card ATR
    providerlist: list of GUIDs of interfaces supported by smart card



    Searches the smart card database and provides a list of named cards
    previously introduced to the system by the user.  The caller specifies an
    ATR string, a set of interface identifiers (GUIDs), or both.  If both an
    ATR string and an identifier array are supplied, the cards returned will
    match the ATR string supplied and support the interfaces specified.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    ...
    slbCryptoFlex8kv2ATR = [ 0x3B, 0x95, 0x15, 0x40, 0x00, 0x68, 0x01, 0x02, 0x00, 0x00  ]
    hresult, card = SCardListCards(hcontext, slbCryptoFlex8kv2ATR, [])
    if hresult ! =SCARD_S_SUCCESS:
        raise error, 'Failure to locate Schlumberger Cryptoflex 8k v2 card: ' + SCardGetErrorMessage(hresult)
    hresult, cards = SCardListCards(hcontext, [], [])
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failure to list cards: ' + SCardGetErrorMessage(hresult)
    print 'Cards: ', cards
    ...

    """
    return _scard.SCardListCards(hcontext, atr, providerlist)

def SCardLocateCards(hcontext, cards, readerstatelist):
    """
    SCardLocateCards( hcontext,  cards, tuple[] readerstatelist) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    cards: a list of cards to locate
    readerstatelist: in input/output, a list of reader state tuple (readername, state, atr)



    Searches the readers listed in the readerstate parameter for a card
    with an ATR string that matches one of the card names specified in
    mszCards, returning immediately with the result.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, readers = SCardListReaders(hcontext, [])
    readerstates = []
    cards = ['Schlumberger Cryptoflex 4k', 'Schlumberger Cryptoflex 8k', 'Schlumberger Cryptoflex 8k v2']
    for i in xrange(len(readers)):
        readerstates += [(readers[i], SCARD_STATE_UNAWARE)]
    hresult, newstates = SCardLocateCards(hcontext, cards, readerstates)
    for i in newstates:
        reader, eventstate, atr = i
        print reader,
        for b in atr:
            print '0x%.2X' % b,
        print 
        if eventstate & SCARD_STATE_ATRMATCH:
            print 'Card found'
        if eventstate & SCARD_STATE_EMPTY:
            print 'Reader empty'
        if eventstate & SCARD_STATE_PRESENT:
            print 'Card present in reader'
    ...

    """
    return _scard.SCardLocateCards(hcontext, cards, readerstatelist)

def SCardRemoveReaderFromGroup(hcontext, readername, groupname):
    """
    SCardRemoveReaderFromGroup( hcontext,  readername,  groupname) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    readername: card reader name
    groupname: card reader group name




    Removes a reader from an existing reader group.  This function has no
    affect on the reader.

    Windows only, not supported by PCSC lite wrapper.

    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult = SCardRemoveReaderFromGroup(hcontext, 'SchlumbergerSema Reflex USB v.2 0', 'SCard$MyOwnGroup')
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Unable to remove reader from group: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardRemoveReaderFromGroup(hcontext, readername, groupname)

def SCardIsValidContext(hcontext):
    """
    SCardIsValidContext( hcontext) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()



    This function determines whether a smart card context handle is still
    valid.  After a smart card context handle has been set by
    SCardEstablishContext(), it may become not valid if the resource manager
    service has been shut down.

    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult = SCardIsValidContext(hcontext)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Invalid context: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardIsValidContext(hcontext)

def SCardGetAttrib(hcard, dwAttrId):
    """
    SCardGetAttrib( hcard,  dwAttrId) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()
    dwAttrId: value of attribute to get




    This function get an attribute from the IFD Handler.

    The possible attributes are:

    ======================================== ======= =======
    Attribute                                Windows  PSCS  
                                                      lite
    ======================================== ======= =======
    SCARD_ATTR_ASYNC_PROTOCOL_TYPES                     Y   
    SCARD_ATTR_ATR_STRING                       Y       Y   
    SCARD_ATTR_CHANNEL_ID                       Y       Y   
    SCARD_ATTR_CHARACTERISTICS                  Y       Y   
    SCARD_ATTR_CURRENT_BWT                      Y       Y   
    SCARD_ATTR_CURRENT_CLK                      Y       Y   
    SCARD_ATTR_CURRENT_CWT                      Y       Y   
    SCARD_ATTR_CURRENT_D                        Y       Y   
    SCARD_ATTR_CURRENT_EBC_ENCODING             Y       Y   
    SCARD_ATTR_CURRENT_F                        Y       Y   
    SCARD_ATTR_CURRENT_IFSC                     Y       Y   
    SCARD_ATTR_CURRENT_IFSD                     Y       Y   
    SCARD_ATTR_CURRENT_IO_STATE                 Y       Y   
    SCARD_ATTR_CURRENT_N                        Y       Y   
    SCARD_ATTR_CURRENT_PROTOCOL_TYPE            Y       Y   
    SCARD_ATTR_CURRENT_W                        Y       Y   
    SCARD_ATTR_DEFAULT_CLK                      Y       Y   
    SCARD_ATTR_DEFAULT_DATA_RATE                Y       Y   
    SCARD_ATTR_DEVICE_FRIENDLY_NAME_A           Y       Y   
    SCARD_ATTR_DEVICE_FRIENDLY_NAME_W           Y       Y   
    SCARD_ATTR_DEVICE_IN_USE                    Y       Y   
    SCARD_ATTR_DEVICE_SYSTEM_NAME_A             Y       Y   
    SCARD_ATTR_DEVICE_SYSTEM_NAME_W             Y       Y   
    SCARD_ATTR_DEVICE_UNIT                      Y       Y   
    SCARD_ATTR_ESC_AUTHREQUEST                  Y       Y   
    SCARD_ATTR_ESC_CANCEL                       Y       Y   
    SCARD_ATTR_ESC_RESET                        Y       Y   
    SCARD_ATTR_EXTENDED_BWT                     Y       Y   
    SCARD_ATTR_ICC_INTERFACE_STATUS             Y       Y   
    SCARD_ATTR_ICC_PRESENCE                     Y       Y   
    SCARD_ATTR_ICC_TYPE_PER_ATR                 Y       Y   
    SCARD_ATTR_MAXINPUT                         Y       Y   
    SCARD_ATTR_MAX_CLK                          Y       Y   
    SCARD_ATTR_MAX_DATA_RATE                    Y       Y   
    SCARD_ATTR_MAX_IFSD                         Y       Y   
    SCARD_ATTR_POWER_MGMT_SUPPORT               Y       Y   
    SCARD_ATTR_SUPRESS_T1_IFS_REQUEST           Y       Y   
    SCARD_ATTR_SYNC_PROTOCOL_TYPES                      Y   
    SCARD_ATTR_USER_AUTH_INPUT_DEVICE           Y       Y   
    SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE         Y       Y   
    SCARD_ATTR_VENDOR_IFD_SERIAL_NO             Y       Y   
    SCARD_ATTR_VENDOR_IFD_TYPE                  Y       Y   
    SCARD_ATTR_VENDOR_IFD_VERSION               Y       Y   
    SCARD_ATTR_VENDOR_NAME                      Y       Y   
    ======================================== ======= =======

    Not all the dwAttrId values listed above may be implemented in the IFD
    Handler you are using.  And some dwAttrId values not listed here may be
    implemented.


    from smartcard.scard import *
    ... establish context and connect to card ...
    hresult, attrib = SCardGetAttrib(hcard, SCARD_ATTR_ATR_STRING)
    if hresult == SCARD_S_SUCCESS:
        for j in attrib:
             print '0x%.2X' % attrib,
    ...

    """
    return _scard.SCardGetAttrib(hcard, dwAttrId)

def SCardSetAttrib(hcard, dwAttrId, ATTRIBUTESIN):
    """
    SCardSetAttrib( hcard,  dwAttrId, BYTELIST * ATTRIBUTESIN) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()
    dwAttrId: value of attribute to get
    ATTRIBUTESIN: BYTELIST *




    This function sets an attribute from the IFD Handler. Not all
    attributes are supported by all readers nor can they be set at all
    times.

    The possible attributes are:

    ======================================== ======= =======
    Attribute                                Windows  PSCS  
                                                      lite
    ======================================== ======= =======
    SCARD_ATTR_ASYNC_PROTOCOL_TYPES                     Y   
    SCARD_ATTR_ATR_STRING                       Y       Y   
    SCARD_ATTR_CHANNEL_ID                       Y       Y   
    SCARD_ATTR_CHARACTERISTICS                  Y       Y   
    SCARD_ATTR_CURRENT_BWT                      Y       Y   
    SCARD_ATTR_CURRENT_CLK                      Y       Y   
    SCARD_ATTR_CURRENT_CWT                      Y       Y   
    SCARD_ATTR_CURRENT_D                        Y       Y   
    SCARD_ATTR_CURRENT_EBC_ENCODING             Y       Y   
    SCARD_ATTR_CURRENT_F                        Y       Y   
    SCARD_ATTR_CURRENT_IFSC                     Y       Y   
    SCARD_ATTR_CURRENT_IFSD                     Y       Y   
    SCARD_ATTR_CURRENT_IO_STATE                 Y       Y   
    SCARD_ATTR_CURRENT_N                        Y       Y   
    SCARD_ATTR_CURRENT_PROTOCOL_TYPE            Y       Y   
    SCARD_ATTR_CURRENT_W                        Y       Y   
    SCARD_ATTR_DEFAULT_CLK                      Y       Y   
    SCARD_ATTR_DEFAULT_DATA_RATE                Y       Y   
    SCARD_ATTR_DEVICE_FRIENDLY_NAME_A           Y       Y   
    SCARD_ATTR_DEVICE_FRIENDLY_NAME_W           Y       Y   
    SCARD_ATTR_DEVICE_IN_USE                    Y       Y   
    SCARD_ATTR_DEVICE_SYSTEM_NAME_A             Y       Y   
    SCARD_ATTR_DEVICE_SYSTEM_NAME_W             Y       Y   
    SCARD_ATTR_DEVICE_UNIT                      Y       Y   
    SCARD_ATTR_ESC_AUTHREQUEST                  Y       Y   
    SCARD_ATTR_ESC_CANCEL                       Y       Y   
    SCARD_ATTR_ESC_RESET                        Y       Y   
    SCARD_ATTR_EXTENDED_BWT                     Y       Y   
    SCARD_ATTR_ICC_INTERFACE_STATUS             Y       Y   
    SCARD_ATTR_ICC_PRESENCE                     Y       Y   
    SCARD_ATTR_ICC_TYPE_PER_ATR                 Y       Y   
    SCARD_ATTR_MAXINPUT                         Y       Y   
    SCARD_ATTR_MAX_CLK                          Y       Y   
    SCARD_ATTR_MAX_DATA_RATE                    Y       Y   
    SCARD_ATTR_MAX_IFSD                         Y       Y   
    SCARD_ATTR_POWER_MGMT_SUPPORT               Y       Y   
    SCARD_ATTR_SUPRESS_T1_IFS_REQUEST           Y       Y   
    SCARD_ATTR_SYNC_PROTOCOL_TYPES                      Y   
    SCARD_ATTR_USER_AUTH_INPUT_DEVICE           Y       Y   
    SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE         Y       Y   
    SCARD_ATTR_VENDOR_IFD_SERIAL_NO             Y       Y   
    SCARD_ATTR_VENDOR_IFD_TYPE                  Y       Y   
    SCARD_ATTR_VENDOR_IFD_VERSION               Y       Y   
    SCARD_ATTR_VENDOR_NAME                      Y       Y   
    ======================================== ======= =======

    Not all the dwAttrId values listed above may be implemented in the IFD
    Handler you are using.  And some dwAttrId values not listed here may be
    implemented.


    from smartcard.scard import *
    ... establish context and connect to card ...
    hresult, attrib = SCardSetAttrib(hcard, SCARD_ATTR_VENDOR_NAME, ['G', 'e', 'm', 'a', 'l', 't', 'o'])
    if hresult != SCARD_S_SUCCESS:
         print 'Failed to set attribute'
    ...

    """
    return _scard.SCardSetAttrib(hcard, dwAttrId, ATTRIBUTESIN)

def SCardControl(hcard, dwControlCode, inbuffer):
    """
    SCardControl( hcard,  dwControlCode, byte[] inbuffer) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()
    dwControlCode: the control code to send
    inbuffer: list of bytes to send with the control code



    This function sends a control command to the reader connected to by
    SCardConnect().  It returns a result and the control response.


    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, hcard, dwActiveProtocol = SCardConnect(
         hcontext, 'SchlumbergerSema Reflex USB v.2 0', SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0)
    CMD = [0x12, 0x34]
    hresult, response = SCardControl(hcard, 42, CMD)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to control: ' + SCardGetErrorMessage(hresult)

    """
    return _scard.SCardControl(hcard, dwControlCode, inbuffer)

def SCardBeginTransaction(hcard):
    """
    SCardBeginTransaction( hcard) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()



    This function establishes a temporary exclusive access mode for doing a
    series of commands or transaction.  You might want to use this when you
    are selecting a few files and then writing a large file so you can make
    sure that another application will not change the current file.  If
    another application has a lock on this reader or this application is in
    SCARD_SHARE_EXCLUSIVE there will be no action taken.

    from smartcard.scard import *
    ... establish context ...
    hresult, hcard, dwActiveProtocol = SCardConnect(
        hcontext, 'SchlumbergerSema Reflex USB v.2 0', SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0)
    if hresult!=SCARD_S_SUCCESS:
        raise error, 'unable to connect: ' + SCardGetErrorMessage(hresult)
    hresult = SCardBeginTransaction(hcard)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'failed to begin transaction: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardBeginTransaction(hcard)

def SCardCancel(hcontext):
    """
    SCardCancel( hcontext) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()



    This function cancels all pending blocking requests on the
    ScardGetStatusChange() function.

    from smartcard.scard import *
    ... establish context ...
    hresult = SCardCancel(hcard)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'failed to cancel pending actions: ' + SCardGetErrorMessage(hresult)
    ...
    """
    return _scard.SCardCancel(hcontext)

def SCardConnect(hcontext, readername, dwShareMode, dwPreferredProtocols):
    """
    SCardConnect( hcontext,  readername,  dwShareMode,  dwPreferredProtocols) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    readername: card reader name
    dwShareMode: share mode
    dwPreferredProtocols: preferred protocols



    This function establishes a connection to the friendly name of the reader
    specified in szReader.  The first connection will power up and perform a
    reset on the card.

    Value of dwShareMode    Meaning
    SCARD_SHARE_SHARED      This application will allow others to share the reader
    SCARD_SHARE_EXCLUSIVE   This application will NOT allow others to share the reader
    SCARD_SHARE_DIRECT      Direct control of the reader, even without a card

    SCARD_SHARE_DIRECT can be used before using SCardControl() to send control
    commands to the reader even if a card is not present in the reader.

    Value of dwPreferredProtocols   Meaning
    SCARD_PROTOCOL_T0               Use the T=0 protocol
    SCARD_PROTOCOL_T1               Use the T=1 protocol
    SCARD_PROTOCOL_RAW              Use with memory type cards

    from smartcard.scard import *
    ... establish context ...
    hresult, readers = SCardListReaders(hcontext, 'NULL')
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to list readers:: ' + SCardGetErrorMessage(hresult)
    hresult, hcard, dwActiveProtocol = SCardConnect(
        hcontext, readers[0], SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'unable to connect: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardConnect(hcontext, readername, dwShareMode, dwPreferredProtocols)

def SCardDisconnect(hcard, dwDisposition):
    """
    SCardDisconnect( hcard,  dwDisposition) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()
    dwDisposition: card disposition on return



    This function terminates a connection to the connection made through
    SCardConnect.  disposition can have the following values:

    Value of disposition    Meaning
    SCARD_LEAVE_CARD        Do nothing
    SCARD_RESET_CARD        Reset the card (warm reset)
    SCARD_UNPOWER_CARD      Unpower the card (cold reset)
    SCARD_EJECT_CARD        Eject the card

    from smartcard.scard import *
    ... establish context and connect to card ...
    hresult = SCardDisconnect(hcard, SCARD_UNPOWER_CARD)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'failed to disconnect: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardDisconnect(hcard, dwDisposition)

def SCardEndTransaction(hcard, dwDisposition):
    """
    SCardEndTransaction( hcard,  dwDisposition) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()
    dwDisposition: card disposition on return




    This function ends a previously begun transaction.  The calling
    application must be the owner of the previously begun transaction or an
    error will occur.  disposition can have the following values: The
    disposition action is not currently used in this release.

    Value of disposition    Meaning
    SCARD_LEAVE_CARD        Do nothing
    SCARD_RESET_CARD        Reset the card
    SCARD_UNPOWER_CARD      Unpower the card
    SCARD_EJECT_CARD        Eject the card

    from smartcard.scard import *
    ... establish context, connect to card, begin transaction ...
    hresult = SCardEndTransaction(hcard, SCARD_LEAVE_CARD)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'failed to end transaction: ' + SCardGetErrorMessage(hresult)

    """
    return _scard.SCardEndTransaction(hcard, dwDisposition)

def SCardEstablishContext(dwScope):
    """
    SCardEstablishContext( dwScope) -> SCARDRETCODE

    Parameters
    ----------
    dwScope: context scope



    This function creates a communication context to the PC/SC Resource
    Manager.  This must be the first function called in a PC/SC application.

    Value of dwScope        Meaning
    SCARD_SCOPE_USER        Operations performed within the scope of the User
    SCARD_SCOPE_TERMINAL    Not used
    SCARD_SCOPE_GLOBAL      Not used
    SCARD_SCOPE_SYSTEM      Operations performed within the scope of the system


    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to establish context: ' + SCardGetErrorMessage(hresult)

    """
    return _scard.SCardEstablishContext(dwScope)

def SCardGetStatusChange(hcontext, dwTimeout, readerstatelist):
    """
    SCardGetStatusChange( hcontext,  dwTimeout, tuple[] readerstatelist) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    dwTimeout: timeout value, INFINITE for infinite time-out
    readerstatelist: in input/output, a list of reader state tuple (readername, state, atr)




    This function receives a structure or list of tuples containing reader
    states. A READERSTATE hast three fields (readername, state, atr).
    It then blocks for a change in state to occur on any of the OR'd
    values contained in the current state for a maximum blocking time of
    dwTimeout or forever if INFINITE is used.  The new event state will be
    contained in state.  A status change might be a card insertion or
    removal event, a change in ATR, etc.

    Value of state              Meaning
    SCARD_STATE_UNAWARE         The application is unaware of the current state, and would like to know. The use of this value results in an immediate return from state transition monitoring services. This is represented by all bits set to zero
    SCARD_STATE_IGNORE          This reader should be ignored
    SCARD_STATE_CHANGED         There is a difference between the state believed by the application, and the state known by the resource manager. When this bit is set, the application may assume a significant state change has occurred on this reader
    SCARD_STATE_UNKNOWN         The given reader name is not recognized by the resource manager. If this bit is set, then SCARD_STATE_CHANGED and SCARD_STATE_IGNORE will also be set
    SCARD_STATE_UNAVAILABLE     The actual state of this reader is not available. If this bit is set, then all the following bits are clear
    SCARD_STATE_EMPTY           There is no card in the reader. If this bit is set, all the following bits will be clear
    SCARD_STATE_PRESENT         There is a card in the reader
    SCARD_STATE_ATRMATCH        There is a card in the reader with an ATR matching one of the target cards. If this bit is set, SCARD_STATE_PRESENT will also be set. This bit is only returned on the SCardLocateCards function
    SCARD_STATE_EXCLUSIVE       The card in the reader is allocated for exclusive use by another application. If this bit is set, SCARD_STATE_PRESENT will also be set
    SCARD_STATE_INUSE           The card in the reader is in use by one or more other applications, but may be connected to in shared mode. If this bit is set, SCARD_STATE_PRESENT will also be set
    SCARD_STATE_MUTE            There is an unresponsive card in the reader


    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, readers = SCardListReaders(hcontext, [])
    readerstates = []
    cards = [ 'Schlumberger Cryptoflex 4k', 'Schlumberger Cryptoflex 8k', 'Schlumberger Cryptoflex 8k v2' ]
    for i in xrange(len(readers)):
        readerstates += [ (readers[i], SCARD_STATE_UNAWARE) ]
    hresult, newstates = SCardLocateCards(hcontext, cards, readerstates)
    print '----- Please insert or remove a card ------------'
    hresult, newstates = SCardGetStatusChange(hcontext, INFINITE, newstates)
    for i in newstates
         reader, eventstate, atr = i
        if eventstate & SCARD_STATE_ATRMATCH:
            print '	Card found'
        if eventstate & SCARD_STATE_EMPTY:
            print '	Reader empty'

    """
    return _scard.SCardGetStatusChange(hcontext, dwTimeout, readerstatelist)

def SCardListReaders(hcontext, readergroups):
    """
    SCardListReaders( hcontext, [] readergroups) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()
    readergroups: a list of reader groups to search for readers



    This function returns a list of currently available readers on the system.
    A list of group can be provided in input to list readers in a given
    group only.

    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, readers = SCardListReaders(hcontext, [])
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to list readers: ' + SCardGetErrorMessage(hresult)
    print 'PCSC Readers: ', readers
    hresult, readers = SCardListReaders(hcontext, ['SCard$T1ProtocolReaders', 'SCard$MyOwnGroup']
    ...

    """
    return _scard.SCardListReaders(hcontext, readergroups)

def SCardListReaderGroups(hcontext):
    """
    SCardListReaderGroups( hcontext) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()



    This function returns a list of currently available reader groups on the
    system.

    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, readerGroups = SCardListReaderGroups(hcontext)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Unable to list reader groups: ' + SCardGetErrorMessage(hresult)
    print 'PCSC Reader groups: ', readerGroups

    """
    return _scard.SCardListReaderGroups(hcontext)

def SCardReconnect(hcard, dwShareMode, dwPreferredProtocols, dwInitialization):
    """
    SCardReconnect( hcard,  dwShareMode,  dwPreferredProtocols,  dwInitialization) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()
    dwShareMode: share mode
    dwPreferredProtocols: preferred protocols
    dwInitialization: the type of initialization that should be performed on the card




    This function reestablishes a connection to a reader that was previously
    connected to using SCardConnect().  In a multi application environment it
    is possible for an application to reset the card in shared mode.  When
    this occurs any other application trying to access certain commands will
    be returned the value SCARD_W_RESET_CARD.  When this occurs
    SCardReconnect() must be called in order to acknowledge that the card was
    reset and allow it to change it's state accordingly.

    Value of dwShareMode    Meaning
    SCARD_SHARE_SHARED      This application will allow others to share the reader
    SCARD_SHARE_EXCLUSIVE   This application will NOT allow others to share the reader

    Value of dwPreferredProtocols   Meaning
    SCARD_PROTOCOL_T0               Use the T=0 protocol
    SCARD_PROTOCOL_T1               Use the T=1 protocol
    SCARD_PROTOCOL_RAW              Use with memory type cards

    dwPreferredProtocols is a bit mask of acceptable protocols for the connection. You can use (SCARD_PROTOCOL_T0 | SCARD_PROTOCOL_T1) if you do not have a preferred protocol.

    Value of dwInitialization   Meaning
    SCARD_LEAVE_CARD            Do nothing
    SCARD_RESET_CARD            Reset the card (warm reset)
    SCARD_UNPOWER_CARD          Unpower the card (cold reset)
    SCARD_EJECT_CARD            Eject the card


    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, hcard, dwActiveProtocol = SCardConnect(
        hcontext, 'SchlumbergerSema Reflex USB v.2 0', SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0)
    hresult, activeProtocol = SCardReconnect(hcard, SCARD_SHARE_EXCLUSIVE,
        SCARD_PROTOCOL_T0, SCARD_RESET_CARD)
    ...

    """
    return _scard.SCardReconnect(hcard, dwShareMode, dwPreferredProtocols, dwInitialization)

def SCardReleaseContext(hcontext):
    """
    SCardReleaseContext( hcontext) -> SCARDRETCODE

    Parameters
    ----------
    hcontext: context handle return from SCardEstablishContext()




    """
    return _scard.SCardReleaseContext(hcontext)

def SCardStatus(hcard):
    """
    SCardStatus( hcard) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()



    This function returns the current status of the reader connected to by
    hcard.  The reader friendly name is returned, as well as the state,
    protocol and ATR.  The state is a DWORD possibly OR'd with the following
    values:

    Value of pdwState   Meaning
    SCARD_ABSENT        There is no card in the reader
    SCARD_PRESENT       There is a card in the reader, but it has not been moved into position for use
    SCARD_SWALLOWED     There is a card in the reader in position for use. The card is not powered
    SCARD_POWERED       Power is being provided to the card, but the reader driver is unaware of the mode of the card
    SCARD_NEGOTIABLE    The card has been reset and is awaiting PTS negotiation
    SCARD_SPECIFIC      The card has been reset and specific communication protocols have been established

    Value of pdwProtocol    Meaning
    SCARD_PROTOCOL_T0       Use the T=0 protocol
    SCARD_PROTOCOL_T1       Use the T=1 protocol


    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, hcard, dwActiveProtocol = SCardConnect(
             hcontext, 'SchlumbergerSema Reflex USB v.2 0', SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0)
    hresult, reader, state, protocol, atr = SCardStatus(hcard)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'failed to get status: ' + SCardGetErrorMessage(hresult)
    print 'Reader: ', reader
    print 'State: ', state
    print 'Protocol: ', protocol
    print 'ATR: ',
    for i in xrange(len(atr)):
        print '0x%.2X' % i,
    print 
    ...

    """
    return _scard.SCardStatus(hcard)

def SCardTransmit(hcard, pioSendPci, apducommand):
    """
    SCardTransmit( hcard, unsigned long pioSendPci, byte[] apducommand) -> SCARDRETCODE

    Parameters
    ----------
    hcard: card handle return from SCardConnect()
    pioSendPci: unsigned long
    apducommand: list of APDU bytes to transmit



    This function sends an APDU to the smart card contained in the reader
    connected to by SCardConnect().
    It returns a result and the card APDU response.

    Value of pioSendPci     Meaning
    SCARD_PCI_T0            Pre-defined T=0 PCI structure
    SCARD_PCI_T1            Pre-defined T=1 PCI structure


    from smartcard.scard import *
    hresult, hcontext = SCardEstablishContext(SCARD_SCOPE_USER)
    hresult, hcard, dwActiveProtocol = SCardConnect(
         hcontext, 'SchlumbergerSema Reflex USB v.2 0', SCARD_SHARE_SHARED, SCARD_PROTOCOL_T0)
    SELECT = [0xA0, 0xA4, 0x00, 0x00, 0x02]
    DF_TELECOM = [0x7F, 0x10]
    hresult, response = SCardTransmit(hcard, SCARD_PCI_T0, SELECT + DF_TELECOM)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to transmit: ' + SCardGetErrorMessage(hresult)

    """
    return _scard.SCardTransmit(hcard, pioSendPci, apducommand)

def SCARD_CTL_CODE(code):
    """
    SCARD_CTL_CODE(long code) -> long

    Parameters
    ----------
    code: long



    This function returns the value of a control code

    from smartcard.scard import *
    ...
    CM_IOCTL_GET_FEATURE_REQUEST = SCARD_CTL_CODE(3400)
    ...

    """
    return _scard.SCARD_CTL_CODE(code)

def SCardGetErrorMessage(lErrCode):
    """
    SCardGetErrorMessage(long lErrCode) -> ERRORSTRING *

    Parameters
    ----------
    lErrCode: long



    This function return a human readable text for the given PC/SC error code.

    from smartcard.scard import *
    ...
    hresult, response = SCardTransmit(hcard, SCARD_PCI_T0, SELECT + DF_TELECOM)
    if hresult != SCARD_S_SUCCESS:
        raise error, 'Failed to transmit: ' + SCardGetErrorMessage(hresult)
    ...

    """
    return _scard.SCardGetErrorMessage(lErrCode)

error = _scard.error

SCARD_SCOPE_USER = _scard.SCARD_SCOPE_USER
SCARD_SCOPE_TERMINAL = _scard.SCARD_SCOPE_TERMINAL
SCARD_SCOPE_SYSTEM = _scard.SCARD_SCOPE_SYSTEM
SCARD_SHARE_SHARED = _scard.SCARD_SHARE_SHARED
SCARD_SHARE_EXCLUSIVE = _scard.SCARD_SHARE_EXCLUSIVE
SCARD_SHARE_DIRECT = _scard.SCARD_SHARE_DIRECT
SCARD_LEAVE_CARD = _scard.SCARD_LEAVE_CARD
SCARD_RESET_CARD = _scard.SCARD_RESET_CARD
SCARD_UNPOWER_CARD = _scard.SCARD_UNPOWER_CARD
SCARD_EJECT_CARD = _scard.SCARD_EJECT_CARD
SCARD_STATE_UNAWARE = _scard.SCARD_STATE_UNAWARE
SCARD_STATE_IGNORE = _scard.SCARD_STATE_IGNORE
SCARD_STATE_CHANGED = _scard.SCARD_STATE_CHANGED
SCARD_STATE_UNKNOWN = _scard.SCARD_STATE_UNKNOWN
SCARD_STATE_UNAVAILABLE = _scard.SCARD_STATE_UNAVAILABLE
SCARD_STATE_EMPTY = _scard.SCARD_STATE_EMPTY
SCARD_STATE_PRESENT = _scard.SCARD_STATE_PRESENT
SCARD_STATE_ATRMATCH = _scard.SCARD_STATE_ATRMATCH
SCARD_STATE_EXCLUSIVE = _scard.SCARD_STATE_EXCLUSIVE
SCARD_STATE_INUSE = _scard.SCARD_STATE_INUSE
SCARD_STATE_MUTE = _scard.SCARD_STATE_MUTE
SCARD_STATE_UNPOWERED = _scard.SCARD_STATE_UNPOWERED
SCARD_PROTOCOL_UNDEFINED = _scard.SCARD_PROTOCOL_UNDEFINED
SCARD_PROTOCOL_T0 = _scard.SCARD_PROTOCOL_T0
SCARD_PROTOCOL_T1 = _scard.SCARD_PROTOCOL_T1
SCARD_PROTOCOL_RAW = _scard.SCARD_PROTOCOL_RAW
SCARD_PROTOCOL_Tx = _scard.SCARD_PROTOCOL_Tx
SCARD_PROTOCOL_DEFAULT = _scard.SCARD_PROTOCOL_DEFAULT
SCARD_PROTOCOL_OPTIMAL = _scard.SCARD_PROTOCOL_OPTIMAL
SCARD_PROTOCOL_UNSET = _scard.SCARD_PROTOCOL_UNSET
SCARD_PROTOCOL_ANY = _scard.SCARD_PROTOCOL_ANY
SCARD_PROTOCOL_T15 = _scard.SCARD_PROTOCOL_T15
SCARD_PCI_T0 = _scard.SCARD_PCI_T0
SCARD_PCI_T1 = _scard.SCARD_PCI_T1
SCARD_PCI_RAW = _scard.SCARD_PCI_RAW
SCARD_PROVIDER_PRIMARY = _scard.SCARD_PROVIDER_PRIMARY
SCARD_PROVIDER_CSP = _scard.SCARD_PROVIDER_CSP
SCARD_ATTR_VENDOR_NAME = _scard.SCARD_ATTR_VENDOR_NAME
SCARD_ATTR_VENDOR_IFD_TYPE = _scard.SCARD_ATTR_VENDOR_IFD_TYPE
SCARD_ATTR_VENDOR_IFD_VERSION = _scard.SCARD_ATTR_VENDOR_IFD_VERSION
SCARD_ATTR_VENDOR_IFD_SERIAL_NO = _scard.SCARD_ATTR_VENDOR_IFD_SERIAL_NO
SCARD_ATTR_CHANNEL_ID = _scard.SCARD_ATTR_CHANNEL_ID
SCARD_ATTR_DEFAULT_CLK = _scard.SCARD_ATTR_DEFAULT_CLK
SCARD_ATTR_MAX_CLK = _scard.SCARD_ATTR_MAX_CLK
SCARD_ATTR_DEFAULT_DATA_RATE = _scard.SCARD_ATTR_DEFAULT_DATA_RATE
SCARD_ATTR_MAX_DATA_RATE = _scard.SCARD_ATTR_MAX_DATA_RATE
SCARD_ATTR_MAX_IFSD = _scard.SCARD_ATTR_MAX_IFSD
SCARD_ATTR_POWER_MGMT_SUPPORT = _scard.SCARD_ATTR_POWER_MGMT_SUPPORT
SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE = _scard.SCARD_ATTR_USER_TO_CARD_AUTH_DEVICE
SCARD_ATTR_USER_AUTH_INPUT_DEVICE = _scard.SCARD_ATTR_USER_AUTH_INPUT_DEVICE
SCARD_ATTR_CHARACTERISTICS = _scard.SCARD_ATTR_CHARACTERISTICS
SCARD_ATTR_CURRENT_PROTOCOL_TYPE = _scard.SCARD_ATTR_CURRENT_PROTOCOL_TYPE
SCARD_ATTR_CURRENT_CLK = _scard.SCARD_ATTR_CURRENT_CLK
SCARD_ATTR_CURRENT_F = _scard.SCARD_ATTR_CURRENT_F
SCARD_ATTR_CURRENT_D = _scard.SCARD_ATTR_CURRENT_D
SCARD_ATTR_CURRENT_N = _scard.SCARD_ATTR_CURRENT_N
SCARD_ATTR_CURRENT_W = _scard.SCARD_ATTR_CURRENT_W
SCARD_ATTR_CURRENT_IFSC = _scard.SCARD_ATTR_CURRENT_IFSC
SCARD_ATTR_CURRENT_IFSD = _scard.SCARD_ATTR_CURRENT_IFSD
SCARD_ATTR_CURRENT_BWT = _scard.SCARD_ATTR_CURRENT_BWT
SCARD_ATTR_CURRENT_CWT = _scard.SCARD_ATTR_CURRENT_CWT
SCARD_ATTR_CURRENT_EBC_ENCODING = _scard.SCARD_ATTR_CURRENT_EBC_ENCODING
SCARD_ATTR_EXTENDED_BWT = _scard.SCARD_ATTR_EXTENDED_BWT
SCARD_ATTR_ICC_PRESENCE = _scard.SCARD_ATTR_ICC_PRESENCE
SCARD_ATTR_ICC_INTERFACE_STATUS = _scard.SCARD_ATTR_ICC_INTERFACE_STATUS
SCARD_ATTR_CURRENT_IO_STATE = _scard.SCARD_ATTR_CURRENT_IO_STATE
SCARD_ATTR_ATR_STRING = _scard.SCARD_ATTR_ATR_STRING
SCARD_ATTR_ICC_TYPE_PER_ATR = _scard.SCARD_ATTR_ICC_TYPE_PER_ATR
SCARD_ATTR_ESC_RESET = _scard.SCARD_ATTR_ESC_RESET
SCARD_ATTR_ESC_CANCEL = _scard.SCARD_ATTR_ESC_CANCEL
SCARD_ATTR_ESC_AUTHREQUEST = _scard.SCARD_ATTR_ESC_AUTHREQUEST
SCARD_ATTR_MAXINPUT = _scard.SCARD_ATTR_MAXINPUT
SCARD_ATTR_DEVICE_UNIT = _scard.SCARD_ATTR_DEVICE_UNIT
SCARD_ATTR_DEVICE_IN_USE = _scard.SCARD_ATTR_DEVICE_IN_USE
SCARD_ATTR_DEVICE_FRIENDLY_NAME_A = _scard.SCARD_ATTR_DEVICE_FRIENDLY_NAME_A
SCARD_ATTR_DEVICE_SYSTEM_NAME_A = _scard.SCARD_ATTR_DEVICE_SYSTEM_NAME_A
SCARD_ATTR_DEVICE_FRIENDLY_NAME_W = _scard.SCARD_ATTR_DEVICE_FRIENDLY_NAME_W
SCARD_ATTR_DEVICE_SYSTEM_NAME_W = _scard.SCARD_ATTR_DEVICE_SYSTEM_NAME_W
SCARD_ATTR_SUPRESS_T1_IFS_REQUEST = _scard.SCARD_ATTR_SUPRESS_T1_IFS_REQUEST
ERROR_ALREADY_EXISTS = _scard.ERROR_ALREADY_EXISTS
SCARD_S_SUCCESS = _scard.SCARD_S_SUCCESS
SCARD_F_INTERNAL_ERROR = _scard.SCARD_F_INTERNAL_ERROR
SCARD_E_CANCELLED = _scard.SCARD_E_CANCELLED
SCARD_E_INVALID_HANDLE = _scard.SCARD_E_INVALID_HANDLE
SCARD_E_INVALID_PARAMETER = _scard.SCARD_E_INVALID_PARAMETER
SCARD_E_INVALID_TARGET = _scard.SCARD_E_INVALID_TARGET
SCARD_E_NO_MEMORY = _scard.SCARD_E_NO_MEMORY
SCARD_F_WAITED_TOO_LONG = _scard.SCARD_F_WAITED_TOO_LONG
SCARD_E_INSUFFICIENT_BUFFER = _scard.SCARD_E_INSUFFICIENT_BUFFER
SCARD_E_UNKNOWN_READER = _scard.SCARD_E_UNKNOWN_READER
SCARD_E_TIMEOUT = _scard.SCARD_E_TIMEOUT
SCARD_E_SHARING_VIOLATION = _scard.SCARD_E_SHARING_VIOLATION
SCARD_E_NO_SMARTCARD = _scard.SCARD_E_NO_SMARTCARD
SCARD_E_UNKNOWN_CARD = _scard.SCARD_E_UNKNOWN_CARD
SCARD_E_CANT_DISPOSE = _scard.SCARD_E_CANT_DISPOSE
SCARD_E_PROTO_MISMATCH = _scard.SCARD_E_PROTO_MISMATCH
SCARD_E_NOT_READY = _scard.SCARD_E_NOT_READY
SCARD_E_INVALID_VALUE = _scard.SCARD_E_INVALID_VALUE
SCARD_E_SYSTEM_CANCELLED = _scard.SCARD_E_SYSTEM_CANCELLED
SCARD_F_COMM_ERROR = _scard.SCARD_F_COMM_ERROR
SCARD_F_UNKNOWN_ERROR = _scard.SCARD_F_UNKNOWN_ERROR
SCARD_E_INVALID_ATR = _scard.SCARD_E_INVALID_ATR
SCARD_E_NOT_TRANSACTED = _scard.SCARD_E_NOT_TRANSACTED
SCARD_E_READER_UNAVAILABLE = _scard.SCARD_E_READER_UNAVAILABLE
SCARD_E_PCI_TOO_SMALL = _scard.SCARD_E_PCI_TOO_SMALL
SCARD_E_READER_UNSUPPORTED = _scard.SCARD_E_READER_UNSUPPORTED
SCARD_E_DUPLICATE_READER = _scard.SCARD_E_DUPLICATE_READER
SCARD_E_CARD_UNSUPPORTED = _scard.SCARD_E_CARD_UNSUPPORTED
SCARD_E_NO_SERVICE = _scard.SCARD_E_NO_SERVICE
SCARD_E_SERVICE_STOPPED = _scard.SCARD_E_SERVICE_STOPPED
SCARD_E_NO_READERS_AVAILABLE = _scard.SCARD_E_NO_READERS_AVAILABLE
SCARD_E_UNSUPPORTED_FEATURE = _scard.SCARD_E_UNSUPPORTED_FEATURE
SCARD_W_UNSUPPORTED_CARD = _scard.SCARD_W_UNSUPPORTED_CARD
SCARD_W_UNRESPONSIVE_CARD = _scard.SCARD_W_UNRESPONSIVE_CARD
SCARD_W_UNPOWERED_CARD = _scard.SCARD_W_UNPOWERED_CARD
SCARD_W_RESET_CARD = _scard.SCARD_W_RESET_CARD
SCARD_W_REMOVED_CARD = _scard.SCARD_W_REMOVED_CARD
SCARD_W_SECURITY_VIOLATION = _scard.SCARD_W_SECURITY_VIOLATION
SCARD_W_WRONG_CHV = _scard.SCARD_W_WRONG_CHV
SCARD_W_CHV_BLOCKED = _scard.SCARD_W_CHV_BLOCKED
SCARD_W_EOF = _scard.SCARD_W_EOF
SCARD_W_CANCELLED_BY_USER = _scard.SCARD_W_CANCELLED_BY_USER
SCARD_W_CARD_NOT_AUTHENTICATED = _scard.SCARD_W_CARD_NOT_AUTHENTICATED
SCARD_E_UNEXPECTED = _scard.SCARD_E_UNEXPECTED
SCARD_E_ICC_INSTALLATION = _scard.SCARD_E_ICC_INSTALLATION
SCARD_E_ICC_CREATEORDER = _scard.SCARD_E_ICC_CREATEORDER
SCARD_E_DIR_NOT_FOUND = _scard.SCARD_E_DIR_NOT_FOUND
SCARD_E_FILE_NOT_FOUND = _scard.SCARD_E_FILE_NOT_FOUND
SCARD_E_NO_DIR = _scard.SCARD_E_NO_DIR
SCARD_E_NO_FILE = _scard.SCARD_E_NO_FILE
SCARD_E_NO_ACCESS = _scard.SCARD_E_NO_ACCESS
SCARD_E_WRITE_TOO_MANY = _scard.SCARD_E_WRITE_TOO_MANY
SCARD_E_BAD_SEEK = _scard.SCARD_E_BAD_SEEK
SCARD_E_INVALID_CHV = _scard.SCARD_E_INVALID_CHV
SCARD_E_UNKNOWN_RES_MNG = _scard.SCARD_E_UNKNOWN_RES_MNG
SCARD_E_NO_SUCH_CERTIFICATE = _scard.SCARD_E_NO_SUCH_CERTIFICATE
SCARD_E_CERTIFICATE_UNAVAILABLE = _scard.SCARD_E_CERTIFICATE_UNAVAILABLE
SCARD_E_COMM_DATA_LOST = _scard.SCARD_E_COMM_DATA_LOST
SCARD_E_NO_KEY_CONTAINER = _scard.SCARD_E_NO_KEY_CONTAINER
SCARD_E_SERVER_TOO_BUSY = _scard.SCARD_E_SERVER_TOO_BUSY
ERROR_INVALID_HANDLE = _scard.ERROR_INVALID_HANDLE
SCARD_P_SHUTDOWN = _scard.SCARD_P_SHUTDOWN
INFINITE = _scard.INFINITE
resourceManager = _scard.resourceManager
resourceManagerSubType = _scard.resourceManagerSubType
# This file is compatible with both classic and new-style classes.


